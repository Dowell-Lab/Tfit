#include "model_selection.h"
#include "template_matching.h"
#include <stdlib.h> 

/** Determines whether a set of segment_fits is suitable for further processing.
 * 
 * More specifically, this function checks the inputs for invalid values (such as infinities, etc), then 
 * checks whether or not the BIC score of the given fit is better than simple random noise.
 * 
 * @param penalty Scales the model BIC calculation to set a sort of maximum score threshold.
 * @param S Pointer to a segment fitting model.
 * @return Whether or not the given model is suitable.
 */
int BIC(double penalty, segment_fits * S){
	double noise_bic, model_bic;
	if (S->M[0]==nINF and S->M[1]==INF){
		return 0;
	}
	if (S->M[1]==nINF){
		S->M[1]=S->M[0];
	}
	noise_bic 	= -2*S->M[0] + log(S->N)*2;
	model_bic 	= -2*S->M[1] + log(S->N)*7*penalty;
	if (noise_bic < model_bic){
		return 0;
	}
	return 1;
}

/** Determines the error rates in calls generated by a given set of models.
 * 
 * @param penality (penalty?) Thresholding variable used to determine model suitability.
 * @param noise_fits Set of models representing noise.
 * @param query_fits Set of models to check.
 * @param tp Double in which to store the number of true positives.
 * @param fp Double in which to store the number of false positives.
 */
void compute_true_and_false_positive_rates(double penality, vector<segment_fits *> noise_fits,
	vector<segment_fits *> query_fits, double & tp, double & fp ){
	//compute false positives
	for (int i = 0 ; i < noise_fits.size(); i++){
		int s 	=  BIC(penality, noise_fits[i]);
		fp+=s;
	}
	//compute true positives
	for (int i = 0 ; i < query_fits.size(); i++){
		int s 	=  BIC(penality, query_fits[i]);
		tp+=s;
	}
}

/** Computes the Receiver Operating Characteristic of the given models and noise.
 * This determines whether or not a given model is better than chance when compared
 * to a simple noise model.
 * 
 * @param noise_fits Set of noise models to compare query_fits against.
 * @param query_fits Set of models to compare against noise_fits.
 * @param AUC Double in which to store a score representing how accurately the models provided make calls.
 * @param TP Double in which to store the true positive rate.
 * @param FP Double in which to store the false positive rate.
 * @param TP_at_fp Rate of true positives at min false positives.
 * @param FP_at_tp Rate of false positives at min true positives.
 * @param optimal_density Specifies the optimal model density at which the true positive rate is highest relative to the false positive rate.
 * @return No value is actually returned from this function.
 */ 
double ROC(vector<segment_fits *> noise_fits, vector<segment_fits *> query_fits, 
	double& AUC , double& TP, double& FP, double& TP_at_fp, double& FP_at_tp, double& optimal_penality ){
	double res 	= 500;
	printf("%ld, %ld\n", noise_fits.size(), query_fits.size());
	double penality_a 	= -1000; //everything is model
	double penality_b 	= 1000; //everthing is noise
	double delta 		= (penality_b - penality_a)/ res;
	double penality;
	double TPN 			= query_fits.size();
	double TNN 			= noise_fits.size();
	double prev_tp = 1.0, prev_fp = 1.0;
	double max_dist = nINF;
	for (int r = 0; r < res; r++){
		penality 		= penality_a + delta*r;
		double tp = 0,fp = 0;
		compute_true_and_false_positive_rates(penality, noise_fits, query_fits, tp, fp);
		tp /= TPN;
		fp /= TNN;
		AUC+=(prev_fp - fp )*prev_tp;
		if (tp -fp   > max_dist   ){
			TP 	= tp;
			FP 	= fp;
			max_dist 	= tp - fp ;
			optimal_penality 	= penality;
		}
		prev_fp=fp, prev_tp=tp;
		if (fp < pow(10,-5)){
			break;
		}
		if (tp > 0.95){
			FP_at_tp=fp;
		}
		if (fp > 0.05){
			TP_at_fp=tp;
		}

	}

	//NOTE: This function doesn't return a value. This potential stack error has been plugged with the following:
	return 0;
}







